Как мы увидели, основной для большинства коллекций является реализация интерфейсов IEnumerable и IEnumerator. Благодаря такой реализации мы можем перебирать объекты в цикле foreach.
Интерфейс IEnumerable имеет метод, возвращающий ссылку на другой интерфейс - перечислитель:
1
2
3
4	public interface IEnumerable
{
    IEnumerator GetEnumerator();
}
	
А интерфейс IEnumerator определяет функционал для перебора внутренних объектов в контейнере:
1
2
3
4
5
6	public interface IEnumerator
{
    bool MoveNext();       // перемещение на одну 
   позицию вперед в контейнере элементов
    object Current {get;}  // текущий элемент в контейнере
    void Reset();          // перемещение в начало контейнера
}
	
Возьмем пример с классом Library из прошлой темы и реализуем в этом классе интерфейс IEnumerable:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55	class Book
{
    public Book(string name)
    {
        this.Name=name;
    }
    public string Name { get; set; }
}
class Library : IEnumerable
{
    private Book[] books;
 
    public Library()
    {
        books = new Book[] { new Book("Отцы и дети"), new Book("Война и мир"), 
                new Book("Евгений Онегин") };
    }
 
    public int Length
    {
        get { return books.Length; }
    }
 
    public Book this[int index]
    {
        get
        {
            return books[index];
        }
        set
        {
            books[index] = value;
        }
    }
         
    // возвращаем перечислитель
    IEnumerator IEnumerable.GetEnumerator()
    {
        return books.GetEnumerator();
    }
}
class Program
{
    static void Main(string[] args)
    {
        Library library = new Library();
 
        foreach (Book b in library)
        {
            Console.WriteLine(b.Name);
        }
 
        Console.ReadLine();
    }
}
Так как у нас массивы также реализуют интерфейс IEnumerator, то в методе реализации просто обратиться к перечислителю этого массива:
1
2
3
4	IEnumerator IEnumerable.GetEnumerator()
{
    return books.GetEnumerator();
}
И в программе мы сможем пройтись по объекту Library в цикле foreach.












Еще один распространенный тип коллекции представляют словари. Словарь хранит объекты, которые представляют пару ключ-значение. Каждый такой объект является объектом класса KeyValuePair<TKey, TValue>. Благодаря свойствам Key и Value, которые есть у данного класса, мы можем получить ключ и значение элемента в словаре.
Рассмотрим на примере использование словарей:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18	Dictionary<int, string> countries = new Dictionary<int, string>(5);
countries.Add(1, "Russia");
countries.Add(3, "Great Britain");
countries.Add(2, "USA");
countries.Add(4, "France");
countries.Add(5, "China");          
 
foreach (KeyValuePair<int, string> keyValue in countries)
{
    Console.WriteLine(keyValue.Key + " - " + keyValue.Value);
}
 
// получение элемента по ключу
string country = countries[4];
// изменение объекта
countries[4] = "Spain";
// удаление по ключу
countries.Remove(2);
Класс словарей также, как и другие коллекции, предоставляет методы Add и Remove для добавления и удаления элементов. Только в случае словарей в метод Add передаются два параметра: ключ и значение. А метод Remove удаляет не по индексу, а по ключу.
Так как в нашем примере ключами является объекты типа int, а значениями - объекты типа string, то словарь в нашем случае будет хранить объекты KeyValuePair<int, string>. В цикле foreach мы их можем получить и извлечь их них ключ и значение.
Кроме того, мы можем получить отдельно коллекции ключей и значений словаря:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22	Dictionary<char, Person> people = new Dictionary<char, Person>();
people.Add('b', new Person() { Name = "Bill" });
people.Add('t', new Person() { Name = "Tom" }); 
people.Add('j', new Person() { Name = "John" });
 
foreach (KeyValuePair<char, Person> keyValue in people)
{
    // keyValue.Value представляет класс Person
    Console.WriteLine(keyValue.Key + " - " + keyValue.Value.Name); 
}
 
// перебор ключей
foreach (char c in people.Keys)
{
    Console.WriteLine(c);
}
 
// перебор по значениям
foreach (Person p in people.Values)
{
    Console.WriteLine(p.Name);
}
Здесь в качестве ключей выступают объекты типа char, а значениями - объекты Person. Используя свойство Keys, мы можем получить ключи словаря, а свойство Values соответственно хранит все значения в словаре.
Для добавления необязательно применять метод Add(), можно использовать сокращенный вариант:
1
2
3	Dictionary<char, Person> people = new Dictionary<char, Person>();
people.Add('b', new Person() { Name = "Bill" });
people['a'] = new Person() { Name = "Alice" };
Несмотря на то, что изначально в словаре нет ключа 'a' и соответствующего ему элемента, то он все равно будет установлен. Если же он есть, то элемент по ключу 'a' будет заменен на новый объект new Person() { Name = "Alice" }
Инициализация словарей
В C# 5.0 мы могли инициализировать словари следующим образом:
1
2
3
4
5
6
7
8
9
10	Dictionary<string, string> countries = new Dictionary<string, string>
{
    {"Франция", "Париж"},
    {"Германия", "Берлин"},
    {"Великобритания", "Лондон"}
};
 
foreach(var pair in countries)
    Console.WriteLine("{0} - {1}", pair.Key, pair.Value);
            
То начиная с C# 6.0 (Visual Studio 2015) доступен также еще один способ инициализации:
1
2
3
4
5
6	Dictionary<string, string> countries = new Dictionary<string, string>
{
    ["Франция"]= "Париж",
    ["Германия"]= "Берлин",
    ["Великобритания"]= "Лондон"
};       







Класс List<T> представляет простейший список однотипных объектов.Среди его методов можно выделить следующие:
•	void Add(T item): добавление нового элемента в список
•	void AddRange(ICollection collection): добавление с список коллекции или массива
•	int BinarySearch(T item): бинарный поиск элемента в списке. Если элемент найден, то метод возвращает индекс этого элемента в коллекции. При этом список должен быть отсортирован.
•	int IndexOf(T item): возвращает индекс первого вхождения элемента в списке
•	void Insert(int index, T item): вставляет элемент item в списке на позицию index
•	bool Remove(T item): удаляет элемент item из списка, и если удаление прошло успешно, то возвращает true
•	void RemoveAt(int index): удаление элемента по указанному индексу index
•	void Sort(): сортировка списка
Посмотрим реализацию списка на примере:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
	using System;
using System.Collections.Generic;
 
namespace Collections
{
    class Program
    {
        static void Main(string[] args)
        {
            List<int> numbers = new List<int>() { 1, 2, 3, 45 };
            numbers.Add(6); // добавление элемента
 
            numbers.AddRange(new int[] { 7, 8, 9 });
 
            numbers.Insert(0, 666); // вставляем на первое место 
                                       в списке число 666 
            numbers.RemoveAt(1); //  удаляем второй элемент
 
            foreach (int i in numbers)
            {
                Console.WriteLine(i);
            }
 
            List<Person> people = new List<Person>(3);
            people.Add(new Person() { Name = "Том" });
            people.Add(new Person() { Name = "Билл" });
 
            foreach (Person p in people)
            {
                Console.WriteLine(p.Name);
            }
 
            Console.ReadLine();
        }
    }
 
    class Person
    {
        public string Name { get; set; }
    }
}
Здесь у нас создаются два списка: один для объектов типа int, а другой - для объектов Person. В первом случае мы выполняем начальную инициализацию списка: List<int> numbers = new List<int>() { 1, 2, 3, 45 };
Во втором случае мы используем другой конструктор, в который передаем начальную емкость списка: List<Person> people = new List<Person>(3);. Указание начальной емкости списка (capacity) позволяет в будущем увеличить производительность и уменьшить издержки на выделение памяти при добавлении элементов. Также начальную емкость можно установить с помощью свойства Capacity, которое имеется у класса List.









































/// Класс для одной вершины дерева
/// <typeparam name="T">Элемент дерева. Сюда можно вставить всё, что можно сравнить =)</typeparam>

class Node<T> where T : IComparable
{
    public Node<T> Left { get; set; }
    public Node<T> Right { get; set; }
    public T Element { get; set; }

    public Node(T element)
    {
        Element = element;
    }
}


/// Общее дерево для сортировки элементов
/// <typeparam name="T">Элемент дерева. Сюда можно вставить всё, что можно сравнить =)</typeparam>

class Tree<T> where T: IComparable
{

    /// Постоянная ссылка на корень. Нужна, чтобы не "потярть" дерево и служит точкой отсчет при рекурсивных обходах

    protected Node<T> _root;

    /// Метод служит для добавления нового элемента в дерево
    /// <param name="newElement">Новый элемент</param>

    public void AddElement(T newElement)
    {
        if (_root == null)         //Добавление первого элемента, своего рода инициализация дерева
        {
            //Так как дерево пустое, то просто инициализируем корень, без всяких проверок и вычислений
            _root = new Node<T>(newElement);
            return;
        }

        //Если корень уже есть, то заходим в него и начинаем вычислять, куда добавить текущий элемент
        AddElementRecursion(_root, newElement);
    }

   


    /// Рекурсивный метод для добавления элемента в дерево
    /// Рассматривается текущая вершина currentNode и анализируется, куда надо добавлять новый элемент, в левое или правое поддерево
    /// <param name="currentNode">Текущая вершина</param>
    /// <param name="newElement">Добавляемый элемент</param>

    private static void AddElementRecursion(Node<T>currentNode, T newElement)
    {
//Если новый элемент меньше текущего
     if (currentNode.Element.CompareTo(newElement) < 0)       
    {
            // То заходим в его правую ветку
            if (currentNode.Right == null)      // Если правой ветки не было, то создаем правого детёныша, и, соответственно, заканчивается добавление
                currentNode.Right = new Node<T>(newElement);
            else     //Если же правая ветка есть, то входим в нее, и повторяем такую же процедуру
                AddElementRecursion(currentNode.Right, newElement);
        }
        else      //Иначе, если новый элемент больше или равен текущему
        {
            // То заходим в его левую ветку
            if ( currentNode.Left == null )
 // Если левой ветки не было, то создаем левого детёныша, и, соответственно, заканчивается добавление
                currentNode.Left = new Node<T>(newElement);
            else 
//Если же левая ветка есть, то входим в нее, и повторяем такую же процедуру
                AddElementRecursion(currentNode.Left, newElement);
        }

    }


















    /// Пример использования дерева. Поиск минимального элемента
    /// <returns>Найденный минимальный элемент</returns>

    public T GetMinElement()
    {
        //указываем, что надо начинать искать с корня, и уходим в рекурсию
        return GetMinElementRecursion(_root);
    }


    /// Рекурсивный метод для поиска минимального элемента в дереве
    /// Рассматривается текущая вершина currentNode и анализируется, где дальше надо искать минимальный элемента, в левом или правом поддереве   
    /// <param name="currentNode">Текущая вершина</param>
    /// <returns>Найденный минимальный элемент</returns>

    private static T GetMinElementRecursion(Node<T> currentNode)
    {
            if (currentNode.Left == null)
            return currentNode.Element;
        else
            return GetMinElementRecursion(currentNode.Left);
    }
}


/// Конкретизированное дерево на тип double, расширяем предыдущее дерево

class TreeDoubleType : Tree<double>
{
    /// Пример рекурсивного обхода дерева. Поиск суммы всех элементив
    /// <returns>Найденная сумма всех элементов</returns>

    public double GetSum()
    {
        //Инициализация суммы
        double sum = 0;
        //Уход в рекурсию для поиска суммы
        GetSumRecursion(_root, ref sum);
        return sum;
    }









    /// Рекурсивный метод для поиска минимального элемента в дереве
    /// Рассматривается текущая вершина currentNode и анализируется, где дальше надо искать минимальный элемента, в левом или правом поддереве
    /// <param name="currentNode">Текущая вершина</param>
    /// <param name="sum">Текущая сумма</param>

    private static void GetSumRecursion(Node<double> currentNode, ref double sum)
    {
        //Прибавляем элемент из текущей вершины
        sum += currentNode.Element;
        //Считаем сумму для левого поддерева
        if (currentNode.Left != null)
            GetSumRecursion(currentNode.Left, ref sum);
        //Считаем сумму для левого поддерева
        if (currentNode.Right != null)
            GetSumRecursion(currentNode.Right, ref sum);
    }
}




//Далее использование дерева, вставлять куда необходимо :)

            //Массив, взятый из головы для примера
            double[] doubleArray = new [] {1, 5, -1.4, 7, 3, 0, 4, -1, 6, 10, 8.4, 5, -7, -6, 5, 3, 7, -2};

            //Создание дерева
            TreeDoubleType tree = new TreeDoubleType();
            
            //Заполнение дерева
            foreach (double d in doubleArray)
                tree.AddElement(d);

            //Работа с деревом
            double min = tree.GetMinElement();
            double sum = tree.GetSum();

            Console.WriteLine("Минимальный элемент дерева: {0}", min);
            Console.WriteLine("Сумма элементов дерева: {0}", sum);











Как я читал данные из файла и переводил в массив значений int:

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


class Program
{
    static void Main(string[] args)
    {
        string fileName = "dataFile.txt";

        string line = File.ReadAllText(fileName);

        Console.WriteLine("Это строка из файла dataFile.txt \n");

        Console.WriteLine(line);

        Console.WriteLine();

        List<int> list = line.Split(new[] { " ", ".", ",", "\n" }, StringSplitOptions.RemoveEmptyEntries).Select(int.Parse).ToList();

        list.Sort();

        Console.WriteLine("Это отсортированный список значений int из файла dataFile.txt \n");

        foreach (int num in list)
            Console.Write(num + " ");

        Console.ReadKey();

    }
}
    
// Обратите внимание, у меня в текстовом файле две строки

Это строка из файла dataFile.txt

12 13 7 6 4 3 8 -5 -1 7 9 11 25 17 18 22
5 19 98 8 9 10 13 54

Это отсортированный список значений int из файла dataFile.txt

-5 -1 3 4 5 6 7 7 8 8 9 9 10 11 12 13 13 17 18 19 22 25 54 98





Создаешь структуру "Вершина дерева", которая имеет две ссылки на структуры "Вершина дерева" (то есть на себя же), а так же можешь вписывать значения, которые должна хранить вершина.
Потом создаешь класс "Дерево", в котором хранишь ссылку на элемент типа "Вершина дерева". Это будет корнем. А от корня уже можно плясать как хочешь.
Код специально не пишу, потому что вроде как тут все понятно, если тебе знакомы понятия "класс" и "ссылка".

Собственно, так создается бинарное дерево на многих (всех?) ООП-языках.



class Node
{
    public Node Left {get; set; }
    public Node Right {get; set; }
    public int Value {get; set; }
}


class Tree
{
    private Node _root;
   
    Tree()
    {
        _root = new Node();
    }
}




































using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TreeBinary
{

class Node<T> where T : IComparable
{
    public Node<T> Left { get; set; }
    public Node<T> Right { get; set; }
    public T Element { get; set; }

    public Node(T element)
    {
        Element = element;
    }
}

class Tree<T> where T : IComparable
{
    protected Node<T> _root;

    public void AddElement(T newElement)
    {
        if (_root == null)
        {
            _root = new Node<T>(newElement);
        }
        else 
            AddElementRecursion(_root, newElement);
    }

    private static void AddElementRecursion(Node<T> currentNode, T newElement)
    {
        if (currentNode.Element.CompareTo(newElement) < 0)
        {
            if (currentNode.Right == null)
                currentNode.Right = new Node<T>(newElement);
            else
                AddElementRecursion(currentNode.Right, newElement);
        }
        else
        {
            if (currentNode.Left == null)
                currentNode.Left = new Node<T>(newElement);
            else
                AddElementRecursion(currentNode.Left, newElement);
        }
    }

    public T GetMinElement()
    {
        return GetMinElementRecursion(_root);
    }

    public static T GetMinElementRecursion(Node<T> currentNode)
    {
        if (currentNode.Left == null)
            return currentNode.Element;
        else
            return GetMinElementRecursion(currentNode.Left);
    }

}      //  class Tree<T> закончился


class TreeDoubleType : Tree<double>
{
    public double GetSum()
    {
        double sum = 0;
        GetSumRecursion(_root, ref sum);
        return sum;
    }

    private static void GetSumRecursion(Node<double> currentNode, ref double sum)
    {
        sum += currentNode.Element;

        if (currentNode.Left != null)
            GetSumRecursion(currentNode.Left, ref sum);

        if (currentNode.Right != null)
            GetSumRecursion(currentNode.Right, ref sum);
    }

    public new double GetMinElement()
    {
        return GetMinElementRecursion(_root);
    }

    public static new double GetMinElementRecursion(Node<double> currentNode)
    {
        if (currentNode.Left == null)
            return currentNode.Element;
        else
            return GetMinElementRecursion(currentNode.Left);
    }







    public bool SearchElement(double value)
    {
        if (_root.Element == value)
            return true;
        if (_root.Element < value)
        {
            Console.Write(_root.Element + " ");
            return SearchElementRecursion(_root.Right, value);
        }
        else
        {
            Console.Write(_root.Element + " ");
            return SearchElementRecursion(_root.Left, value);
        }
    }

    public static bool SearchElementRecursion(Node<double> currentNode, double value)
    {
        if (currentNode == null) return false;

        if (currentNode.Element == value)
            return true;
        if (currentNode.Element < value)
        {
            Console.Write(currentNode.Element + " ");
            return SearchElementRecursion(currentNode.Right, value);
        }
        else
        {
            Console.Write(currentNode.Element + " ");
            return SearchElementRecursion(currentNode.Left, value);
        }
    }

    public long CountElements()
    {
        return CountElementsRes(_root); 
    }

    private long CountElementsRes(Node<double> currentNode)
    {
        long count = 1;

        if (currentNode.Right != null)
        {
            count += CountElementsRes(currentNode.Right);
        }
        if (currentNode.Left != null)
        {
            count += CountElementsRes(currentNode.Left);                
        }
        return count;
    }

}           // class TreeDoubleType  закончился
class Program
{    

static void Main(string[] args)
{
    string fileName = "dataFile.txt";

    string line = File.ReadAllText(fileName);

    Console.WriteLine("Это данные из файла dataFile.txt \n");

    Console.WriteLine(line);

    List<double> list = line
                                     .Split(new[] {" ", "\n"}, StringSplitOptions.RemoveEmptyEntries)
                                     .Select(double.Parse).ToList();

    Console.WriteLine("Это список значений double из файла dataFile.txt \n");

    foreach (double d in list)
        Console.Write(d + " ");

    TreeDoubleType tree = new TreeDoubleType();

    foreach (double d in list)
        tree.AddElement(d);

    double min = tree.GetMinElement();
    double sum = tree.GetSum();            

    Console.WriteLine("\nМинимальный элемент дерева: {0:F}", min);
    Console.WriteLine("\nСумма элементов дерева: {0:F}\n", sum);
   
    double findElement = -1.2; 
    bool elem = tree.SearchElement(findElement);
   
    Console.WriteLine("\n\nИмеется ли элемент {0} в дереве: {1}", findElement, elem);

    long countTree = tree.CountElements();

    Console.WriteLine("\nКоличество узлов в дереве: {0}\n", countTree);

    Console.ReadKey();

}
}
}








Это данные из файла dataFile.txt

13,5 7 6 4 3,3 8,6 -5,1 -1,2 7 9 11,12 25,5 17,1 18,4 12,2

Это список значений double из файла dataFile.txt

13,5 7 6 4 3,3 8,6 -5,1 -1,2 7 9 11,12 25,5 17,1 18,4 12,2

Минимальный элемент дерева: -5,10

Сумма элементов дерева: 136,42

13,5 7 6 4 3,3 -5,1

Имеется ли элемент -1,2 в дереве: True

Количество узлов в дереве: 15






































Моя быстрая сортировка (QuickSort)


static void qsort(double[] t, int a, int b)
{
    if (a >= b) return;

    int res = partition(t, a, b);
    qsort(t, a, res-1);
    qsort(t, res+1, b);
}


static int partition(double[] array, int start, int end)
{
    int marker = start;

    for (int i = start; i <= end; i++)
    {
        if (array[i] <= array[end])
        {
            double temp = array[marker];
            array[marker] = array[i];
            array[i] = temp;
            marker++;
        }
    }
    return marker-1;
}


static void Main(string[] args)
{
    ...   //  здесь ничего не изменилось, можно посмотреть в предыдущих распечатках 

    double[] dbList = new double[list.Count];

    for (int i = 0; i < dbList.Length; i++)
        dbList[i] = list[i];

    Console.WriteLine("Отсортированные данные из файла dataFile.txt \n");

    qsort(dbList, 0, dbList.Length - 1);

    foreach (double d in dbList)
        Console.Write(d + " ");

    Console.ReadKey();
    
}







Это данные из файла dataFile.txt

13,5 7 6 4 3,3 8,6 -5,1 -1,2 7 9 11,12 25,5 17,1 18,4 12,2

Это список значений double из файла dataFile.txt

13,5 7 6 4 3,3 8,6 -5,1 -1,2 7 9 11,12 25,5 17,1 18,4 12,2

Минимальный элемент дерева: -5,10

Сумма элементов дерева: 136,42

13,5 7 6 4 3,3 -5,1

Имеется ли элемент -1,2 в дереве: True

Количество узлов в дереве: 15

Отсортированные данные из файла dataFile.txt

-5,1  -1,2  3,3  4  6  7  7  8,6  9  11,12  12,2  13,5  17,1  18,4  25,5
































Еще несколько реализаций быстрой сортировки

static public void Quicksort(int[] ar)
{
     if (ar.Length > 1) Quicksort(ar, 0, ar.Length - 1);
}
static private void Quicksort(int[] ar, int left, int right)
{
     if (left == right) return;
     int i = left + 1;
     int j = right;
     int pivot = ar[left];

     // Loop invariant i <= j
     while (i < j)
     {
          if (ar[i] <= pivot) i++;
          else if (ar[j] > pivot) j--;
          else
          { // Swap ith and jth elements
               int m = ar[i]; ar[i] = ar[j]; ar[j] = m;
          }
     }
     // Now i == j

     if (ar[j] <= pivot /* it also means that i == right, because j was never moved */)
     {
          // Left most element is array's maximum
          int m = ar[left]; ar[left] = ar[right]; ar[right] = m;
          Quicksort(ar, left, right-1);
     }
     else
     {
          Quicksort(ar, left, i - 1);
          Quicksort(ar, i, right);
     }
}















public void DoQuickSort(int[] arr, long first, long last) {
    int p = arr[(last - first)/2 + first];
    int temp;
    long i = first, j = last;
    while(i <= j) {
        while(arr[i] < p && i <= last)  ++i;
        while(arr[j] > p && j >= first) --j;
        if(i <= j) {
            temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            ++i; --j;
        }
    }
    if(j > first) DoQuickSort(arr, first, j);
    if(i < last)  DoQuickSort(arr, i, last);
}





























class Program
    {
        static void quickSort(int[] a, int l, int r)
        {
            int temp;
            int x = a[l + (r - l) / 2];
            //запись эквивалентна (l+r)/2, 
            //но не вызввает переполнения на больших данных
            int i = l;
            int j = r;
            //код в while обычно выносят в процедуру particle
            while (i <= j)
            {
                while (a[i] < x) i++;
                while (a[j] > x) j--;
                if (i <= j)
                {
                    temp = a[i];
                    a[i] = a[j];
                    a[j] = temp;
                    i++;
                    j--;
                }
            }
            if (i < r)
                quickSort(a, i, r);

            if (l < j)
                quickSort(a, l, j);
        }
        static void Main()
        {
            // Считываем размер массива,
            // который необходимо отсортировать
            int size;
            size = Convert.ToInt32(Console.ReadLine());
            // Динамически выделяем память под
            // хранение массива размера size
            //считываем строку
            string str = Console.ReadLine();
            //разбиваем по пробелам
            string[] mas = str.Split(' ');
            int[] a = new int [size];
            for (int i = 0; i < size; i++)
            {
                a[i] = int.Parse(mas[i]);
            }
            quickSort(a, 0, size - 1);
            // Выводим отсортированный массив
            for (int i = 0; i < size; i++)
            {
                Console.Write(a[i]);
                Console.Write(' ');
            }
        }
    }
Добавил кое-где вывод данных в консоль, для отслеживания хода сортировки

static void qsort(double[] t, int a, int b)
{
    count++;

    Console.WriteLine("\nЗапуск qsort()  {0}, start = {1} end = {2}", count, a, b);

    if (a >= b) return;

    int res = partition(t, a, b);

    Console.WriteLine("\n После вычисления partition(): res = {0}", res); ;            

    qsort(t, a, res-1);
    qsort(t, res+1, b);
}


static int partition(double[] array, int start, int end)
{
    int res = start;

    Console.WriteLine("\n partition(): res = {0}, a = {1} b = {2}", res, start, end);

    Console.WriteLine("\n Начинаем цикл for");

    for (int i = start; i <= end; i++)
    {
        if (array[i] <= array[end])
        {
            double temp = array[res];
            array[res] = array[i];
            array[i] = temp;
            res++;
        }
    }

    Console.WriteLine();

    foreach (double d in array)
        Console.Write(d + " ");

     Console.WriteLine();

    return res-1;
}









static void Main(string[] args)
{
    double[] dbList = new double[]{2, 4, 3, 5, 9, 7, 8, 1, 6};

    qsort(dbList, 0, dbList.Length - 1);

    Console.WriteLine();

    foreach (double d in dbList)
        Console.Write(d + " ");

    Console.ReadKey();
    
}

Вывод работы программы в консоле:

Запуск qsort()  1, start = 0 end = 8

 partition(): res = 0, a = 0 b = 8
 Начинаем цикл for
2 4 3 5 1 6 8 9 7
 После вычисления partition(): res = 5

Запуск qsort()  2, start = 0 end = 4

 partition(): res = 0, a = 0 b = 4
 Начинаем цикл for
1 4 3 5 2 6 8 9 7
 После вычисления partition(): res = 0

Запуск qsort()  3, start = 0 end = -1
return

Запуск qsort()  4, start = 1 end = 4

 partition(): res = 1, a = 1 b = 4
 Начинаем цикл for
1 2 3 5 4 6 8 9 7
 После вычисления partition(): res = 1

Запуск qsort()  5, start = 1 end = 0
return

Запуск qsort()  6, start = 2 end = 4

 partition(): res = 2, a = 2 b = 4
 Начинаем цикл for
1 2 3 4 5 6 8 9 7
 После вычисления partition(): res = 3




Запуск qsort()  7, start = 2 end = 2
return

Запуск qsort()  8, start = 4 end = 4
return

Запуск qsort()  9, start = 6 end = 8

 partition(): res = 6, a = 6 b = 8
 Начинаем цикл for
1 2 3 4 5 6 7 9 8
 После вычисления partition(): res = 6

Запуск qsort()  10, start = 6 end = 5
return

Запуск qsort()  11, start = 7 end = 8

 partition(): res = 7, a = 7 b = 8
 Начинаем цикл for
1 2 3 4 5 6 7 8 9
 После вычисления partition(): res = 7

Запуск qsort()  12, start = 7 end = 6
return

Запуск qsort()  13, start = 8 end = 8
return


Отсортированный массив:

1 2 3 4 5 6 7 8 9













































static void Main(string[] args)
{
    string fileName = "dataFile.txt";
    string line = File.ReadAllText(fileName);
    Console.WriteLine("Это данные из файла dataFile.txt \n");
    Console.WriteLine(line);
    
    List<double> list = line
                            .Split(new[] { " ", "\n" }, StringSplitOptions
                            .RemoveEmptyEntries).Select(double.Parse)
                            .ToList();

    Console.WriteLine("Это список значений double из списка list:\n");

    foreach (double d in list)
        Console.Write(d + " ");

    Console.WriteLine("\n\nСоздадим бинарное дерево класса TreeDoubleType\n");
    Console.WriteLine("Заполним дерево элементами списка list.");

    TreeDoubleType tree = new TreeDoubleType();

    foreach (double d in list)
        tree.AddElement(d);

    double min = tree.GetMinElement();
    double sum = tree.GetSum();

    Console.WriteLine("\nМинимальный элемент дерева: {0:F}", min);
    Console.WriteLine("\nСумма элементов дерева: {0:F}\n", sum);

    double findElement = 7;
    bool elem = tree.SearchElement(findElement);
    Console.WriteLine("\n\nИмеется ли элемент {0} в дереве: {1}", findElement, elem);

    long countTree = tree.CountElements();
    Console.WriteLine("\nКоличество узлов в дереве: {0}\n", countTree);

    double[] dbList = new double[list.Count];

    for (int i = 0; i < dbList.Length; i++)
        dbList[i] = list[i];

    Console.WriteLine("\nОтсортированные данные из файла dataFile.txt\n");

    qsort(dbList, 0, dbList.Length - 1);
    
    foreach (double d in dbList)
        Console.Write(d + " ");

    int num = BinarySearch(dbList, findElement, 0, dbList.Length);

    Console.WriteLine("\n\nИндекс элемента {0} в массиве dbList: {1}", findElement, num);
    Console.ReadKey();   
}
}
Это данные из файла dataFile.txt

13,5 7 6 4 3,3 8,6 -5,1 -1,2 7 9 11,12 25,5 17,1 18,4 12,2

Это список значений double из списка list:

13,5 7 6 4 3,3 8,6 -5,1 -1,2 7 9 11,12 25,5 17,1 18,4 12,2


Создадим бинарное дерево класса TreeDoubleType

Заполним дерево элементами списка list.

Минимальный элемент дерева: -5,10

Сумма элементов дерева: 136,42

13,5

Имеется ли элемент 7 в дереве: True

Количество узлов в дереве: 15


Отсортированные данные из файла dataFile.txt

-5,1 -1,2 3,3 4 6 7 7 8,6 9 11,12 12,2 13,5 17,1 18,4 25,5

Индекс элемента 7 в массиве dbList: 5



























class Program
{
    static void SortedList(int[] tab)
    {
        bool swapped;

        do
        {
            swapped = false;
                            
            for (int i = 1; i < tab.Length; i++)
            {
                if (tab[i-1].CompareTo(tab[i]) > 0)
                {
                    Swap(tab, i-1, i);
                    swapped = true;
                }
            }

        } while (swapped != false);

    }

    static void Swap(int[] tet, int a, int b)
    {
        if (a != b)
        {
            int temp = tet[a];
            tet[a] = tet[b];
            tet[b] = temp; 

        }
    }

    





















    static void qsort(double[] t, int a, int b)
    {
        if (a >= b) return;

        int res = partition(t, a, b);                      

        qsort(t, a, res-1);
        qsort(t, res+1, b);
    }

    static int partition(double[] array, int start, int end)
    {
        int res = start;

        for (int i = start; i <= end; i++)
        {
            if (array[i] <= array[end])
            {
                double temp = array[res];
                array[res] = array[i];
                array[i] = temp;
                res++;
            }
        }

        return res-1;
    }

    static void quickSort()
    {

    }


static int BinarySearch(double[] t, double x, int a, int b)
{
if (a >= b) return -1;

int mid = a + ((b - a) / 2);

if (t[mid] == x) return mid;

if (t[mid] < x)
    return BinarySearch(t, x, mid + 1, b);
else
    return BinarySearch(t, x, a, mid - 1);
}









public void printTree()
{
    if (this != null)
    {
        Console.WriteLine("ROOT : {0}", this._root.Element);
        printTreeNode(_root);
    }
}

public static void printTreeNode(Node<double> currentNode)
{
    if (currentNode.Left != null)
    {
        Console.WriteLine("     LEFT   for  {1}:  {0}", currentNode.Left.Element, currentNode.Element);
    }

    if (currentNode.Right != null)
    {
        Console.WriteLine("     RIGHT  for  {1}:  {0}", currentNode.Right.Element, currentNode.Element);
    }

    if (currentNode.Left != null) printTreeNode(currentNode.Left);
    if (currentNode.Right != null) printTreeNode(currentNode.Right);

}


Сделаю вывод только команды:

tree.printTree();

ROOT : 13,5
     LEFT     for   13,5:  7
     RIGHT  for   13,5:  25,5
     LEFT     for   7:  6
     RIGHT  for   7:  8,6
     LEFT     for   6:  4
     RIGHT  for   6:  7
     LEFT     for   4:  3,3
     LEFT     for   3,3:  -5,1
     RIGHT  for   -5,1:  -1,2
     RIGHT  for   8,6:  9
     RIGHT  for   9:  11,12
     RIGHT  for   11,12:  12,2
     LEFT     for   25,5:  17,1
     RIGHT  for   17,1:  18,4








Быстрая сортировка на PHP, хорошее описание
/*
* Функция, непосредственно производящая сортировку.
* Так как массив передается по ссылке, ничего не возвращает.
*/

function custom_sort(&$array, $left, $right) {

  //Создаем копии пришедших переменных, с которыми будем манипулировать в дальнейшем.
  $l = $left;
  $r = $right;
  
  //Вычисляем 'центр', на который будем опираться. Берем значение ~центральной ячейки массива.
  $center = $array[(int)($left + $right) / 2];
  
  //Цикл, начинающий саму сортировку
  do {
  
    //Ищем значения больше 'центра'
    while ($array[$r] > $center) { 
      $r--;
    }
    
    //Ищем значения меньше 'центра'
    while ($array[$l] < $center) { 
      $l++;
    }
  
    //После прохода циклов проверяем счетчики циклов
    if ($l <= $r) {
    
      //И если условие true, то меняем ячейки друг с другом.
       if ($array[$l] > $array[$r])   list($array[$r], $array[$l]) = array($array[$l], $array[$r]);
      
      //И переводим счетчики на следующий элементы
      $l++;
      $r--;
    }
  
  //Повторяем цикл, если true
  } while ($l <= $r);
  
  if ($r > $left) {
    //Если условие true, совершаем рекурсию
    //Передаем массив, исходное начало и текущий конец
    custom_sort($array, $left, $r); 
  }
  
  if ($l < $right) {
    //Если условие true, совершаем рекурсию
    //Передаем массив, текущие начало и конец
    custom_sort($array, $l, $right);
  }

//Сортировка завершена
}
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TreeBinary
{
class Node<T> where T : IComparable
{
public Node<T> Left { get; set; }
public Node<T> Right { get; set; }
public T Element { get; set; }

public Node(T element)
{
    Element = element;
}
}

class Tree<T> where T : IComparable
{
protected Node<T> _root;

public void AddElement(T newElement)
{
    if (_root == null)
    {
        _root = new Node<T>(newElement);
    }
    else 
        AddElementRecursion(_root, newElement);
}

private static void AddElementRecursion(Node<T> currentNode, T newElement)
{
    if (currentNode.Element.CompareTo(newElement) < 0)
    {
        if (currentNode.Right == null)
            currentNode.Right = new Node<T>(newElement);
        else
            AddElementRecursion(currentNode.Right, newElement);
    }
    else
    {
        if (currentNode.Left == null)
            currentNode.Left = new Node<T>(newElement);
        else
            AddElementRecursion(currentNode.Left, newElement);
    }
}



public T GetMinElement()
{
    return GetMinElementRecursion(_root);
}

public static T GetMinElementRecursion(Node<T> currentNode)
{
    if (currentNode.Left == null)
        return currentNode.Element;
    else
        return GetMinElementRecursion(currentNode.Left);
}

}

class TreeDoubleType : Tree<double>
{
public double GetSum()
{
    double sum = 0;
    GetSumRecursion(_root, ref sum);
    return sum;
}

private static void GetSumRecursion(Node<double> currentNode, ref double sum)
{
    sum += currentNode.Element;

    if (currentNode.Left != null)
        GetSumRecursion(currentNode.Left, ref sum);

    if (currentNode.Right != null)
        GetSumRecursion(currentNode.Right, ref sum);
}

//public new double GetMinElement()
//{
//    return GetMinElementRecursion(_root);
//}

//public static new double GetMinElementRecursion(Node<double> currentNode)
//{
//    if (currentNode.Left == null)
//        return currentNode.Element;
//    else
//        return GetMinElementRecursion(currentNode.Left);
//}









public bool SearchElement(double value)
{
    if (_root.Element == value)
        return true;
    if (_root.Element < value)
    {
        Console.Write(_root.Element + " ");
        return SearchElementRecursion(_root.Right, value);
    }
    else
    {
        Console.Write(_root.Element + " ");
        return SearchElementRecursion(_root.Left, value);
    }
}

public static bool SearchElementRecursion(Node<double> currentNode, double value)
{
    if (currentNode == null) return false;

    if (currentNode.Element == value)
        return true;
    if (currentNode.Element < value)
    {
        Console.Write(currentNode.Element + " ");
        return SearchElementRecursion(currentNode.Right, value);
    }
    else
    {
        Console.Write(currentNode.Element + " ");
        return SearchElementRecursion(currentNode.Left, value);
    }
}

public long CountElements()
{
    return CountElementsRes(_root); 
}

private long CountElementsRes(Node<double> currentNode)
{
    long count = 1;

    if (currentNode.Right != null)
    {
        count += CountElementsRes(currentNode.Right);
    }
    if (currentNode.Left != null)
    {
        count += CountElementsRes(currentNode.Left);                
    }
    return count;
}

public void printTree()
{
    if (this != null)
    {
        Console.WriteLine("ROOT : {0}", this._root.Element);
        printTreeNode(_root);
    }
}

public static void printTreeNode(Node<double> currentNode)
{
    if (currentNode.Left != null)
    {
        Console.WriteLine("     LEFT   for  {1}:  {0}", currentNode.Left.Element, currentNode.Element);
    }

    if (currentNode.Right != null)
    {
        Console.WriteLine("     RIGHT  for  {1}:  {0}", currentNode.Right.Element, currentNode.Element);
    }

    if (currentNode.Left != null) printTreeNode(currentNode.Left);
    if (currentNode.Right != null) printTreeNode(currentNode.Right);

}
}

class Program
{
static void SortedList(int[] tab)
{
    bool swapped;
    do
    {
        swapped = false;                        
        for (int i = 1; i < tab.Length; i++)
        {
            if (tab[i-1].CompareTo(tab[i]) > 0)
            {
                Swap(tab, i-1, i);
                swapped = true;
            }
        }
    } while (swapped != false);
}

static void Swap(int[] tet, int a, int b)
{
    if (a != b)
    {
        int temp = tet[a];
        tet[a] = tet[b];
        tet[b] = temp; 

    }
}


static void qsort(double[] t, int a, int b)
{
    if (a >= b) return;

    int res = partition(t, a, b);                      

    qsort(t, a, res-1);
    qsort(t, res+1, b);
}


static int partition(double[] array, int start, int end)
{
    int res = start;

    for (int i = start; i <= end; i++)
    {
        if (array[i] <= array[end])
        {
            double temp = array[res];
            array[res] = array[i];
            array[i] = temp;
            res++;
        }
    }

    return res-1;
}

static void quickSort()
{

}


static int BinarySearch(double[] t, double x, int a, int b)
{
    if (a >= b) return -1;

    int mid = a + ((b - a) / 2);

    if (t[mid] == x) return mid;

    if (t[mid] < x)
        return BinarySearch(t, x, mid + 1, b);
    else
        return BinarySearch(t, x, a, mid - 1);
}








static void Main(string[] args)
{
    string fileName = "dataFile.txt";

    string line = File.ReadAllText(fileName);

    Console.WriteLine("Это данные из файла dataFile.txt \n");

    Console.WriteLine(line);

    Console.WriteLine();

    List<double> list = line
                                          .Split(new[] { " ", "\n" }, StringSplitOptions.RemoveEmptyEntries)
                                          .Select(double.Parse)
                                          .ToList();

    Console.WriteLine("Это список значений double из списка list:\n");

    foreach (double d in list)
        Console.Write(d + " ");

    Console.WriteLine();

    Console.WriteLine("\n\nСоздадим бинарное дерево класса TreeDoubleType\n");

    Console.WriteLine("Заполним дерево элементами списка list.");

    TreeDoubleType tree = new TreeDoubleType();

    foreach (double d in list)
        tree.AddElement(d);

    double min = tree.GetMinElement();
    double sum = tree.GetSum();

    Console.WriteLine("\nМинимальный элемент дерева: {0:F}", min);
    Console.WriteLine("\nСумма элементов дерева: {0:F}\n", sum);

    double findElement = -5.1;

    Console.WriteLine("\nПуть к элементу {0}\n", findElement);

    bool elem = tree.SearchElement(findElement);

    Console.WriteLine("\n\nИмеется ли элемент {0} в дереве: {1}", findElement, elem);

    long countTree = tree.CountElements();

    Console.WriteLine("\nКоличество узлов в дереве: {0}\n", countTree);

    double[] dbList = new double[list.Count];

    for (int i = 0; i < dbList.Length; i++)
        dbList[i] = list[i];

    Console.WriteLine("\nОтсортированные данные из файла dataFile.txt\n");

    qsort(dbList, 0, dbList.Length - 1);
    
    foreach (double d in dbList)
        Console.Write(d + " ");

    int num = BinarySearch(dbList, findElement, 0, dbList.Length);

    Console.WriteLine("\n\nИндекс элемента {0} в массиве dbList: {1}", findElement, num);

    Console.WriteLine();

    tree.printTree();

    Console.ReadKey();
    
}
}
}



Это данные из файла dataFile.txt

13,5 7 6 4 3,3 8,6 -5,1 -1,2 7 9 11,12 25,5 17,1 18,4 12,2

Это список значений double из списка list:

13,5 7 6 4 3,3 8,6 -5,1 -1,2 7 9 11,12 25,5 17,1 18,4 12,2


Создадим бинарное дерево класса TreeDoubleType

Заполним дерево элементами списка list.

Минимальный элемент дерева: -5,10

Сумма элементов дерева: 136,42


Путь к элементу -5,1

13,5 7 6 4 3,3

Имеется ли элемент -5,1 в дереве: True

Количество узлов в дереве: 15


Отсортированные данные из файла dataFile.txt

-5,1 -1,2 3,3 4 6 7 7 8,6 9 11,12 12,2 13,5 17,1 18,4 25,5

Индекс элемента -5,1 в массиве dbList: -1

ROOT : 13,5
     LEFT   for  13,5:  7
     RIGHT  for  13,5:  25,5
     LEFT   for  7:  6
     RIGHT  for  7:  8,6
     LEFT   for  6:  4
     RIGHT  for  6:  7
     LEFT   for  4:  3,3
     RIGHT   for  4:  NULL
     LEFT   for  3,3:  -5,1
     RIGHT   for  3,3:  NULL
     LEFT   for  -5,1:  NULL
     RIGHT  for  -5,1:  -1,2
     LEFT   for  -1,2:  NULL
     RIGHT   for  -1,2:  NULL
     LEFT   for  7:  NULL
     RIGHT   for  7:  NULL
     LEFT   for  8,6:  NULL
     RIGHT  for  8,6:  9
     LEFT   for  9:  NULL
     RIGHT  for  9:  11,12
     LEFT   for  11,12:  NULL
     RIGHT  for  11,12:  12,2
     LEFT   for  12,2:  NULL
     RIGHT   for  12,2:  NULL
     LEFT   for  25,5:  17,1
     RIGHT   for  25,5:  NULL
     LEFT   for  17,1:  NULL
     RIGHT  for  17,1:  18,4
     LEFT   for  18,4:  NULL
     RIGHT   for  18,4:  NULL

























Для продолжения изучения SQL создадим пример таблицы по продаже печнья несколькими девочками:

CREATE TABLE cookie
(id INT NOT NULL AUTO_INCREMENT,
PRIMARY KEY (id),
name VARCHAR(10),
sales DEC(4,2),
date DATE
)

Заполним её данными:

INSERT INTO cookie
VALUES
(NULL,'Dina',23.15,'2015-01-25'),(NULL,'Rita',12.35,'2015-01-25'),(NULL,'Inga',18.75,'2015-01-25'),
(NULL,'Rita',21.10,'2015-01-26'),(NULL,'Dina',13.55,'2015-01-26'),(NULL,'Inga',20.15,'2015-01-26'),
(NULL,'Rita',29.00,'2015-01-27'),(NULL,'Inga',32.55,'2015-01-27'),(NULL,'Dina',12.85,'2015-01-27'),
(NULL,'Dina',25.15,'2015-01-28'),(NULL,'Inga',15.25,'2015-01-28'),(NULL,'Rita',35.00,'2015-01-28'),
(NULL,'Inga',35.15,'2015-01-29'),(NULL,'Rita',25.15,'2015-01-29'),(NULL,'Dina',15.15,'2015-01-29'),
(NULL,'Rita',15.15,'2015-01-30'),(NULL,'Inga',13.15,'2015-01-30'),(NULL,'Rita',12.25,'2015-01-31')


Наше задание - поределить кто из девочек больше всех выручил на продаже печенья, мы можем отсортировать таблицу по именам и потом вручную сложить кто на сколько продал:

SELECT name, sales
FROM cookie
ORDER BY name;

Но, имея под рукой Базу Днных, считать такую информацию вручную нас не устраивает, т.к. если у нас будет БД размером даже в несколько сотен записей посчитать сумму будет очень напряженнмы делом. 
SQL поможет нам решить эту проблему. 

В языке SQL есть специальные ключевые слова, называемые функциями. Каждая функция выполняет некоторую операцию с одним или несколькими значениями.
Рассмотрим первую функцию (одну из многих), которая выполняет математические операции со столбцом - функция SUM суммирует значения столбца, указанные в круглых скобках, пример:

SELECT SUM(sales)
FROM cookie
WHERE name='Dina';

#	- сумма нашей девушки Дины равна 89.95

Если мы в условии WHERE не укажем name='Dina' функция просуммирует весь столбец sales.

Но если у нас вдруг работают десятки продавцов, то даже такая операция будет трудозатратной и долгой. И  в этом случае SQL вновь помогает нам дополнительными возщможностями при помощи спцеиального условия - GROUP BY, пример:

 
SELECT name, SUM(sales)
FROM cookie
GROUP BY name
ORDER BY SUM(sales) DESC;

# - рассмотрим команду: мы определяем столбцы для выборки, указываем, чтобы группировался столбец name (GROUP BE name) и значения суммы выводились упорядоченно (ORDER BY SUM(sales)) и по убыванию с помощью ключевого слова DESC. В моей SQL всё работает.

Лидер по продажам у нас Рита, у неё 122,60.


Для вычисления размера средней продажи за день используется функция AVG, по синтаксису схожая с SUM, пример:

SELECT name, AVG(sales)
FROM cookie
GROUP BY name
ORDER BY AVG(sales) DESC;

# - пример идентичный, причем в книге не было упорядочивания, я сам уже добавил ORDER BY, но всё работает и с короткой командой и такой расширенной, по средним продажам в день у нас также лидирует Рита.


Если вдруг мы захотим узнать максимум или минимум продаж в день у каждой девушки можно воспользоваться функциями MAX и MIN; для определения наибольшего значения в столбце используется MAX, а для наименьшего значения, соотвественно, MIN. Пример:

SELECT name, MAX(sales)
FROM cookie
GROUP BY name
ORDER BY MAX(sales) DESC;

# - функция дала свой результат, максимальная продажа за день у Инги! У нас наконец-то новый победитель в подсчетах достижений наших девушек.

SELECT name, MIN(sales)
FROM cookie
GROUP BY name
ORDER BY MIN(sales);

# - результаты по минимуму лучше считать без DESС, так минимальное значение окажется первым в нашей выборке. И оказалось что минимальная продажа в день у нас у Риты, победительницы двух выборок, ну зато не так обидно другим девчонкам.


Чтобы узнать какая из девушек больше дней продавала печенье можно использовать функцию COUNT, которая возвращает количество записей в столбце, пример:

SELECT COUNT(date)
FROM cookie;

# - в результате такой команды мы получим ответ - 15, что верно на самом деле, количество записей в столбце sales равно 15.

Но это не даст нам ответа кто из девушек работал больше всех, а только количество всех дней в течении которых продавалось печенье. Вот пример команды для подсчета дней каждой девушки:

SELECT name, COUNT(date)
FROM cookie
GROUP BY name;

# - конечно все девушки у нас работали одинаковое количество дней.


Рассмотрим ключевое слово DISTINCT, проверим его работу без функции COUNT:

SELECT DISTINCT date		# - т.к. DISTINCT это ключевое слово, то имя столбца не нужно брать в скобки
FROM cookie
ORDER BY date;				# - упорядочиваем даты продажи (они у нас и так по порядку, но все-таки так правильнее)

Теперь попробуем выполнить эту команду с функцией COUNT:

SELECT COUNT(DISTINCT date)
FROM cookie;

# - получаем ответ - 7, т.е. количество дней продаж.


К нашим функциям есть некоторые дополнения:

#	-	ключевое слово DISTINCT можно использовать с любым столбцом;

#	-	если в столбце встречается NULL ни одна из этих фенкций не возвратит его, т.к. все они возвращают значения, а NULL - это отсутствие значения, а не нуль;

#	-	не стесняйтесь использовать упорядочивание ORDER BY (что мы и сделали самостоятельно, хотя в книге их не было в некоторых примерах), иногда очень помогает, если результатов много;

#	-	функция MIN, тоже может быть полезной, найти худшее значение или работника, напрмиер.


Разберем пример, если бы у нас было не 3 девушки, а 30 - как бы мы в таком случае вычислили второе место.

Для определения второго места мы будем использовать SUM, вспомним как мы это делали:
   
SELECT name, SUM(sales)
FROM cookie
GROUP BY name
ORDER BY SUM(sales) DESC;

# - команда выдала нам список из трех наших девушек, на первом месте Рита, на втором Инга.

Но если мы хотим ограничить условие выборкой всего первых двух мест, например... В этом нам поможет ключевое слово LIMIT:

SELECT name, SUM(sales)
FROM cookie
GROUP BY name
ORDER BY SUM(sales) DESC
LIMIT 2;

# - очень простой синтаксис, в нашем случае цифра 2 после LIMIT означает, что наш запрос ограничивает первыми двумя результатами,
! важно - если мы забудем написать ключевое слово DESC (ORDER BY SUM(sales) DESC), то результатом команды будут два худших значения!


Ключевое слово LIMIT позволяет нам сделать выборку всего одного результата, рассмотрим синтаксис - для проведения такой операции, LIMIT требуется два параметра: первое - это с какой позиции считать, а второе - это сколько записей вернуть. 
Например если нам из списка 100 песен нужно вернуть песни с 20 по 30 мы должны в первом параметре указывать 19 (т.к. нумерация позиций в SQL начинается с 0 и т.о. 20-я песня будет в позиции 19), а во втором 10, т.е. количество песен, которые нам нужно.
Применим наши знания, чтобы получить значение второго результата (и только второго):   

SELECT name, SUM(sales)
FROM cookie
GROUP BY name
ORDER BY SUM(sales) DESC
LIMIT 1,1;

# - в результате этой команды мы получим значение второго места, а именно Инга : 135,00

# - отметим, что мы указали номер позиции цифрой 1, т.к., не забываем, что в SQL позиции нумеруются с цифры 0, а затем указали количество мест, которые нам нужны со второго, а именно 1, т.к. нам нужно только одно место начиная со второго - а именно второе и нужно.

! важно - Не забываем, что в SQL нумерация начальной позиции начинается с 0, это очень важно!!!




























Давайте вспомним, какие сообщения и в каких темах у нас имеются. Для этого можно воспользоваться привычным запросом: 

 

А что, если нам надо лишь узнать сколько сообщений на форуме имеется. Для этого можно воспользоваться встроенной функцией COUNT(). Эта функция подсчитывает число строк. Причем, если в качестве аргумента этой функции выступает *, то подсчитываются все строки таблицы. А если в качестве аргумента указывается имя столбца, то подсчитываются только те строки, которые имеют значение в указанном столбце.

В нашем примере оба аргумента дадут одинаковый результат, т.к. все столбцы таблицы имеют тип NOT NULL. Давайте напишем запрос, используя в качестве аргумента столбец id_topic: 

     SELECT COUNT(id_topic) FROM posts;
 


 

Итак, в наших темах имеется 4 сообщения. Но что, если мы хотим узнать сколько сообщений имеется в каждой теме. Для этого нам понадобится сгруппировать наши сообщения по темам и вычислить для каждой группы количество сообщений. Для группировки в SQL используется оператор GROUP BY. Наш запрос теперь будет выглядеть так: 

     SELECT id_topic, COUNT(id_topic) FROM posts
     GROUP BY id_topic;
 
Оператор GROUP BY указывает СУБД сгруппировать данные по столбцу id_topic (т.е. каждая тема - отдельная группа) и для каждой группы подсчитать количество строк: 

 

Ну вот, в теме с id=1 у нас 3 сообщения, а с id=4 - одно. Кстати, если бы в поле id_topic были возможны отсутствия значений, то такие строки были бы объединены в отдельную группу со значением NULL.

Предположим, что нас интересуют только те группы, в которых больше двух сообщений. В обычном запросе мы указали бы условие с помощью оператора WHERE, но этот оператор умеет работать только со строками, а для групп те же функции выполняет оператор HAVING: 

     SELECT id_topic, COUNT(id_topic) FROM posts
     GROUP BY id_topic
     HAVING COUNT(id_topic) > 2;
 
В результате имеем: 

 
В уроке 4 мы рассматривали, какие условия можно задавать оператором WHERE, те же условия можно задавать и оператором HAVING, только надо запомнить, что WHERE фильтрует строки, а HAVING - группы.
Итак, сегодня мы узнали, как создавать группы и как подсчитать количество строк в таблице и в группах. Вообще вместе с оператором GROUP BY можно использовать и другие встроенные функции, но их мы будем изучать позже.

Итоговые функции еще называют статистическими, агрегатными или суммирующими. Эти функции обрабатывают набор строк для подсчета и возвращения одного значения. Таких функций всего пять: 
•	AVG() Функция возвращает среднее значение столбца.
•	COUNT() Функция возвращает число строк в столбце.
•	MAX() Функция возвращает самое большое значение в столбце.
•	MIN() Функция возвращает самое маленькое значение в столбце.
•	SUM() Функция возвращает сумму значений столбца.

С одной из них - COUNT() - мы уже познакомились в уроке 8. Сейчас познакомимся с остальными. Предположим, мы захотели узнать минимальную, максимальную и среднюю цену на книги в нашем магазине. Тогда из таблицы Цены (prices) надо взять минимальное, максимальное и среднее значения по столбцу price. Запрос простой: 

     SELECT  MIN(price), MAX(price), AVG(price) FROM prices;
 


 

Теперь, мы хотим узнать, на какую сумму нам привез товар поставщик "Дом печати" (id=2). Составить такой запрос не так просто. Давайте поразмышляем, как его составить:

1. Сначала надо из таблицы Поставки (incoming) выбрать идентификаторы (id_incoming) тех поставок, которые осуществлялись поставщиком "Дом печати" (id=2): 

     SELECT id_incoming FROM incoming
     WHERE id_vendor=2;
 


 

2. Теперь из таблицы Журнал поставок (magazine_incoming) надо выбрать товары (id_product) и их количества (quantity), которые осуществлялись в найденных в пункте 1 поставках. То есть запрос из пункта 1 становится вложенным: 

     SELECT id_product, quantity FROM magazine_incoming
     WHERE  id_incoming=(SELECT id_incoming FROM incoming WHERE id_vendor=2);
 


 

3. Теперь нам надо добавить в результирующую таблицу цены на найденные товары, которые хранятся в таблице Цены (prices). То есть нам понадобится объединение таблиц Журнал поставок (magazine_incoming) и Цены (prices) по столбцу id_product: 

     SELECT magazine_incoming.id_product, magazine_incoming.quantity, prices.price FROM magazine_incoming, prices
     WHERE magazine_incoming.id_product= prices.id_product AND id_incoming=
        (SELECT id_incoming FROM incoming WHERE id_vendor=2);
 


 

4. В получившейся таблице явно не хватает столбца Сумма, то есть вычисляемого столбца. Возможность создания таких столбцов предусмотрена в MySQL. Для этого надо лишь указать в запросе имя вычисляемого столбца и что он должен вычислять. В нашем примере такой столбец будет называться summa, а вычислять он будет произведение столбцов quantity и price. Название нового столбца отделяется словом AS: 

     SELECT magazine_incoming.id_product, magazine_incoming.quantity, prices.price,
     magazine_incoming.quantity*prices.price AS summa
     FROM magazine_incoming, prices
     WHERE magazine_incoming.id_product= prices.id_product AND id_incoming=
     (SELECT id_incoming FROM incoming WHERE id_vendor=2);
 


 

5. Отлично, нам осталось лишь просуммировать столбец summa и наконец-то узнаем, на какую сумму нам привез товар поставщик "Дом печати". Синтаксис для использования функции SUM() следущий: 

     SELECT  SUM(имя_столбца) FROM имя_таблицы;
 
Имя столбца нам известно - summa, а вот имени таблицы у нас нет, так как она является результатом запроса. Что же делать? Для таких случаев в MySQL существуют Представления. Представление - это запрос на выборку, которому присваивается уникальное имя и который можно сохранять в базе данных, для последующего использования. 

Синтаксис создания представления следующий: 

     CREATE VIEW имя_представления AS запрос;
 
Давайте сохраним наш запрос, как представление с именем report_vendor: 

     CREATE VIEW report_vendor AS
     SELECT magazine_incoming.id_product, magazine_incoming.quantity, prices.price,
     magazine_incoming.quantity*prices.price AS summa
     FROM magazine_incoming, prices
     WHERE magazine_incoming.id_product= prices.id_product AND id_incoming=
     (SELECT id_incoming FROM incoming WHERE id_vendor=2);
 
6. Вот теперь можно использовать итоговую функцию SUM(): 

     SELECT SUM(summa) FROM report_vendor;
 


 

Вот мы и достигли результата, правда для этого нам пришлось использовать вложенные запросы, объединения, вычисляемые столбцы и представления. Да, иногда для получения результата приходится подумать, без этого никуда. Зато мы коснулись двух очень важных тем - вычисляемые столбцы и представления. Давайте поговорим о них поподробнее. 
Вычисляемые поля (столбцы)
На примере мы рассмотрели сегодня математическое вычисляемое поле. Здесь хотелось бы добавить, что использовать можно не только операцию умножения (*), но и вычитание (-), и сложение (+), и деление (/). Синтаксис следующий: 

     SELECT имя_столбца_1, имя_столбца_2, имя_столбца_1*имя_столбца_2 AS имя_вычисляемого_столбца
     FROM имя_таблицы;
 
Второй нюанс - ключевое слово AS, мы его использовали для задания имени вычисляемого столбца. На самом деле с помощью этого ключевого слова задаются псевдонимы для любых столбцов. Зачем это нужно? Для сокращения и читаемости кода. Например, наше представление могло бы выглядеть так: 

     CREATE VIEW report_vendor AS
     SELECT A.id_product, A.quantity, B.price, A.quantity*B.price AS summa
     FROM magazine_incoming AS A, prices AS B
     WHERE A.id_product= B.id_product AND id_incoming=
     (SELECT id_incoming FROM incoming WHERE id_vendor=2);
 
Согласитесь, что так гораздо короче и понятнее. 
Представления
Синтаксис создания представлений мы уже рассматривали. После создания представлений, их можно использовать так же, как таблицы. То есть выполнять запросы к ним, фильтровать и сортировать данные, объединять одни представления с другими. С одной стороны это очень удобный способ хранения часто применяемых сложных запросов (как в нашем примере). 

Но следует помнить, что представления - это не таблицы, то есть они не хранят данные, а лишь извлекают их из других таблиц. Отсюда, во-первых, при изменении данных в таблицах, результаты представления так же будут меняться. А во-вторых, при запросе к представлению происходит поиск необходимых данных, то есть производительность СУБД снижается. Поэтому злоупотреблять ими не стоит.


































using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

/*
Желательно сделать связи между классами и методы классов для упрощения расчетов.
* 
* Задание:
- Создать необходимые классы и считать информацию из файлов.
- Вывести на экран информацию о книге, которую чаще всего читают.
- Вывести на экран информацию о самом молодом читателе, а также список книг, которые он читал.
- Вывести на экран информацию о книгах, которые в данный момент находятся на руках.
- Вывести список читателей с информацией, кто сколько дней потратил на чтение книг (считать дни только от out до in, которые ща на руках не учитывать).
* 
*/

namespace LibraryBase
{
class Book 
{
public int BookID {get; set;}
public int YearEditionBook {get; set;}
public string AuthorBook {get; set;}
public string BookName {get; set;}

public Book(int id, string author, string book, int date)
{
    BookID = id;            
    AuthorBook = author;
    BookName = book;
    YearEditionBook = date;
}

public static void PrintPopularBook(List<Book> books, List<Journal> journ)
{
    List<int> list = Journal.PopularBook(journ);
    
    for (int i = 0; i < list.Count; i++)
    {
        PrintBook(books[list[i]-1]);        
    }
}

public static void PrintBookLibrary(List<Book> list)
{
    foreach (Book bk in list)
        PrintBook(bk);
}

public static void PrintBook(Book bookT)
{
    Console.WriteLine(bookT.BookID + " " + bookT.AuthorBook+  " " + bookT.BookName + " " + bookT.YearEditionBook);
}



public static Book AddBook(List<string> list)
{
    int id = int.Parse(list[0]);
    string name = list[1];
    string bookName = list[2];
    int dateBook = int.Parse(list[3]);

    return new Book(id, name, bookName, dateBook);
}

public static List<Book> CreateValuesList(string fileName)
{
    List<string> booksList = new List<string>();
    Program.WriteFileToList(fileName, booksList);
    List<List<string>> books = new List<List<string>>();
    Program.CreateListString(books, booksList);
    List<Book> bookLibrary = new List<Book>();
    foreach (List<string> list in books)
        bookLibrary.Add(Book.AddBook(list));

    return bookLibrary;
}
}

class User
{
public int UserID { get; set; }
public string UserName { get; set; }
public DateTime UserDateBirth { get; set; }

public User(int id, string name, DateTime date)
{
    UserID = id;
    UserName = name;
    UserDateBirth = date;
}          

public static void PrintUserLibrary(List<User> list)
{
    foreach (User ur in list)
        PrintUser(ur);
}

public static void PrintUser(User userT)
{
    Console.WriteLine(userT.UserID + " " + userT.UserName + " " + userT.UserDateBirth.ToString("d"));
}

public static User AddUser(List<string> list)
{
    int id = int.Parse(list[0]);
    string name = list[1];
    DateTime date = DateTime.Parse(list[2]);
    
    return new User(id, name, date);
}
public static List<User> CreateValuesList(string fileName)
{
    List<string> usersList = new List<string>();
    Program.WriteFileToList(fileName, usersList);
    List<List<string>> users = new List<List<string>>();
    Program.CreateListString(users, usersList);
    List<User> usersLibrary = new List<User>();
    foreach (List<string> list in users)
        usersLibrary.Add(User.AddUser(list));

    return usersLibrary;
}

public static DateTime MinDateUser(List<User> list)
{
    DateTime temp = list[0].UserDateBirth;

    for (int i = 1; i < list.Count; i++)
    {
        if (list[i].UserDateBirth < temp)
            temp = list[i].UserDateBirth;
        else { }
    }
    return temp;
}

public static void PrintYoungUserInfo(List<User> list, List<Journal> listJr, List<Book> bkList)
{
    DateTime minDate = User.MinDateUser(list);
    foreach (User usr in list)
    {
        if (usr.UserDateBirth == minDate)
            User.PrintUser(usr);
    }

    int minUserID = 0;

    foreach (User usr in list)
    {
        if (usr.UserDateBirth == minDate)
            minUserID = usr.UserID;
    }

    Console.WriteLine();

    foreach (Journal jorn in listJr)
    {
        if (jorn.UserID == minUserID && jorn.BookInOut == true)
            Book.PrintBook(bkList[jorn.BookID - 1]);
    }
}
}




class Journal
{
public bool BookInOut { get; set; }
public DateTime BookInOutLibrary { get; set; }
public int UserID { get; set; }
public int BookID { get; set; }

public Journal(int x, int y, DateTime date, bool value)
{
    UserID = x;
    BookID = y;
    BookInOutLibrary = date;
    BookInOut = value;
}

public static Journal AddJournal(List<string> list)
{
    int userID = int.Parse(list[0]);
    int bookID = int.Parse(list[1]);
    DateTime tempDate = DateTime.Parse(list[2]);
    bool value;

    if (list[3].Equals("out"))
        value = false;
    else if (list[3].Equals("in"))
        value = true;
    else
    { value = false; }

    return new Journal(userID, bookID, tempDate, value);
}

public static void PrintJournalLibrary(List<Journal> list)
{
    foreach (Journal jr in list)
        PrintJournal(jr);
}

public static void PrintJournal(Journal journ)
{
    Console.WriteLine(journ.UserID + " " + journ.BookID + " " + journ.BookInOutLibrary + " " + journ.BookInOut);
}

public static List<Journal> CreateValuesList(string fileName)
{
    List<string> journalList = new List<string>();
    Program.WriteFileToList(fileName, journalList);
    List<List<string>> journal = new List<List<string>>();
    Program.CreateListString(journal, journalList);
    List<Journal> journalLibrary = new List<Journal>();
    foreach (List<string> list in journal)
        journalLibrary.Add(Journal.AddJournal(list));

    return journalLibrary;
}

public static List<int> PopularBook(List<Journal> list)
{
    var result = from ls in list
                 where ls.BookInOut == false
                 group ls by ls.BookID into b
                 let count = b.Count()
                 select new
                 {
                     Letter = b.Key,
                     Count = count
                 };

    var maxNum = result.Max(n => n.Count);

    List<int> listMax = new List<int>();

    foreach (var item in result)
    {
        if (item.Count == maxNum)
            listMax.Add(item.Letter);
        else
        { }
    }

    return listMax;
}
}


class Program
{
public static void WriteFileToList(string file, List<string> list)
{
    foreach (string str in File.ReadLines(file))
        list.Add(str);
}

public static void CreateListString(List<List<string>> outList, List<string> inList)
{
    foreach (string str in inList)
        outList.Add(str.Split(new[] { "\t" }, StringSplitOptions.RemoveEmptyEntries).ToList());
}   


static void Main(string[] args)
{
    List<Book> bookLibrary = Book.CreateValuesList("books.txt");
    Book.PrintBookLibrary(bookLibrary);

    Console.WriteLine();

    List<User> userLibrary = User.CreateValuesList("user.txt");
    User.PrintUserLibrary(userLibrary);

    Console.WriteLine();

    List<Journal> journalLibrary = Journal.CreateValuesList("journal.txt");
    Journal.PrintJournalLibrary(journalLibrary);

    Console.WriteLine();


    Console.WriteLine("Задание № 1: \"Вывести на экран информацию о книге, которую чаще всего читают\"\n");

    //List<int> popularBook = Journal.PopularBook(journalLibrary);

    Book.PrintPopularBook(bookLibrary, journalLibrary);

    Console.WriteLine("\n");
    

    Console.WriteLine("Задание № 2: \"Вывести на экран информацию о самом молодом читателе, а также список книг, которые он читал\"\n");
                
    User.PrintYoungUserInfo(userLibrary, journalLibrary, bookLibrary);                       

    Console.WriteLine("\n");

    Console.ReadKey();
}
}
}

1 Орловский Гай Ричард Длинные Руки - барон 2005
2 Черненко Алексей Красивое название книги 2015
3 Кош Алекс Огненный Орден 2011
4 Риордан Рик Перси Джексон и проклятие титана 2016
5 Панов Вадим Хаосовершенство 2015

100 Иванов 21.09.1985
101 Петров 17.04.1989
102 Сидоров 08.12.1981

100 4 05.01.2017 0:00:00 False
101 3 09.01.2017 0:00:00 False
102 1 10.01.2017 0:00:00 False
100 4 13.01.2017 0:00:00 True
100 2 16.01.2017 0:00:00 False
102 1 19.01.2017 0:00:00 True
101 3 20.01.2017 0:00:00 True
101 4 23.01.2017 0:00:00 False
102 5 24.01.2017 0:00:00 False
101 4 26.01.2017 0:00:00 True
101 1 27.01.2017 0:00:00 False
100 2 31.01.2017 0:00:00 True
102 5 02.02.2017 0:00:00 True
102 3 07.02.2017 0:00:00 False
101 1 10.02.2017 0:00:00 True
102 3 14.02.2017 0:00:00 True
102 4 15.02.2017 0:00:00 False
100 3 17.02.2017 0:00:00 False
Задание № 1: "Вывести на экран информацию о книге, которую чаще всего читают"

4 Риордан Рик Перси Джексон и проклятие титана 2016
3 Кош Алекс Огненный Орден 2011


Задание № 2: "Вывести на экран информацию о самом молодом читателе, а также список книг, 
которые он читал"

102 Сидоров 08.12.1981

1 Орловский Гай Ричард Длинные Руки - барон 2005
5 Панов Вадим Хаосовершенство 2015
3 Кош Алекс Огненный Орден 2011






books.txt

1	Орловский Гай		Ричард Длинные Руки – барон		2005
2	Черненко Алексей	Красивое название книги			2015
3	Кош Алекс		Огненный Орден				2011
4	Риордан Рик		Перси Джексон и проклятие титана	2016
5	Панов Вадим		Хаосовершенство				2015

journal.txt

100	4	05.01.2017	out
101	3	09.01.2017	out
102	1	10.01.2017	out
100	4	13.01.2017	in
100	2	16.01.2017	out
102	1	19.01.2017	in
101	3	20.01.2017	in
101	4	23.01.2017	out
102	5	24.01.2017	out
101	4	26.01.2017	in
101	1	27.01.2017	out
100	2	31.01.2017	in
102	5	02.02.2017	in
102	3	07.02.2017	out
101	1	10.02.2017	in
102	3	14.02.2017	in
102	4	15.02.2017	out
100	3	17.02.2017	out

user.txt

100	Иванов	21.09.1985
101	Петров	17.04.1989
102	Сидоров	08.12.1981


CompareTo - это сравнение, типа больше, меньше, равно.
Equals - чисто равенство

ты неправильно именуешь методы.
public static User AddUser - метод возвращает юзера, а не добавляет его. лучше назвать GetUser
public static List<User> CreateValuesList - CreateUserList или GetUserList.
ну это на будущее
 
и смотри
public static void PrintPopularBook(List<Book> books, List<Journal> journ)
функция печатает популярную книгу. это больше относится к журналу, туда и надо было запихать ее.
то есть как бы ты у журнала спрашиваешь какая чаще читается.
а ща получается что ты у книги запрашиваешь, какая из книг чаще читается.
как бы с точки зрения программы разницы нет, где функция, но с точки зрения логики - неправильно

и еще я просил сделать связи классов.
как минимум, в классе записи журнала у тебя должны быть 2 ссылки - на книгу и на юзера.
то есть когда ты делаешь AddJournal, ты должен по айдишникам найти соответствующие классы в списках книг и юзеров и сохранить ссылки в свойствах журнала.
тогда было бы проще организовать вывод:
ты говоришь журналу - Дай мне популярную книгу - он по своим записям ее находит и вызывает у нее функцию PrintBook.
по поводу функции PrintBook.
она у тебя static и принимает класс книги.
проще сделать ее внутри класса книги.
и вызывать так: book.PrintBook();
или даже переименовать
book.Print();
а то масло масляное получается

ща глянул: 
PrintPopularBook как раз вызывает Journal.PopularBook
так что надо было всю функцию вынести в Journal

по поводу Linq
поиск самого молодого юзера можно было бы сделать с помощью LINQ так:
User user = list.OrderBy(u => u.UserDateBirth).FirstOrDefault();
то есть отсортировали по дате рождения и взяли первую запись

LINQ  Language-Integrated Query
интегрированный язык запросов
то бишь - интегрированный в .NET

BookInOut - лучше так не называть переменную булевую. ее название должно определять смысл переменной, когда она равна True.
ну например IsReaded - что книга прочитана, HasAuthor - есть автор.
а у тебя непонятно что в переменной - in или out
   
if (list[3].CompareTo("out") == 0)
                value = false;
            else if (list[3].CompareTo("in") == 0)
                value = true;
            else
            { value = false; }


это лучше делать через switch
switch(list[3])
            {
                case "in": value = true; break;
                case "out": value = false; break;
                default: value = false; break;
            }

а еще лучще, раз у тебя только два значения так:
value = (list[3] == "in");

если у тебя может быть несколько значений и надо среди них найти нужный, то лучше писать switch

Александр Ф 21 фев в 11:57 
А как это - сохранить ссылки
это же мне нужно сохранить ссылки на экземпляры соответствующих книг и юзеров, так?
Александр Ф 21 фев в 11:59 
или просто записывать Journal[0].UserID = User[0].UserID;
и т.д. а не значения из файла journal.txt

Константин Фисенко 21 фев в 12:02 
нет. допустим ты парсишь строку журнала. и там айди пользователя 100.
ты ищешь пользака в списке пользователей, например:
User user = userList.FirstOrDefault(u => u.UserID == Journal[i].UserID);
и потом сохраняешь ссылку:
Journal[i].User = user;
а в классе журнала добавляешь поле
public User User{get;set;}
и потом можешь к нему обращаться, например распечатать юзера из записи журнала:
Journal[i].User.Print();

конечно нужно чтоб списки юзеров и книг уже были готовы до парсинга журнала, но у тебя то так и сделано

Константин Фисенко 21 фев в 12:07 
а еще было бы классно внутри класса юзер сделать список записей журнала, которые к нему относятся.
тогда при печати книг, которые прочитал самый молодой юзер, у тебя были бы уже записи журнала на этого юзера, а в этих записях были бы ссылки на книгу, и ты бы их быстренько напечатал
то же самое актуально и для книг
Александр Ф 21 фев в 12:08 
чтобы списки записей хранились в каждом экземпляре?
Константин Фисенко 21 фев в 12:08 
ну
Александр Ф 21 фев в 12:08 
да и об этом я думал
но там уже такая схема выстраивалась ))
я не смог выбрать оптимальный путь, по которому строить дальше классы
Константин Фисенко 21 фев в 12:09 
ну ты же понимаешь, что раз это ссылочные типы, то в списках будут только ссылки, то есть много памяти это не сожрет
Александр Ф 21 фев в 12:09 
вишь, выбрал наглядный, а он оказался, ну это естественно, дилетантским




Александр Ф 21 фев в 12:10 
у меня была твердая мысль, что нужно хранить все соответствующие записи в экземплярах, но потом затупил, показалось - зачем их дублировать, типа есть же журнал
а оказалось это была верная мысль
и об полях User Book в Journal тоже была мысль
но её не додумал потому что ума не хватило уже
Александр Ф 21 фев в 12:12 
и чтобы выбрать книги на руках я просто выбираю все книги у которых сейчас стоит - false
в записях экземпляров















































using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

/*
Желательно сделать связи между классами и методы классов для упрощения расчетов.
* 
* Задание:
- Создать необходимые классы и считать информацию из файлов.
- Вывести на экран информацию о книге, которую чаще всего читают.
- Вывести на экран информацию о самом молодом читателе, а также список книг, которые он читал.
- Вывести на экран информацию о книгах, которые в данный момент находятся на руках.
- Вывести список читателей с информацией, кто сколько дней потратил на чтение книг (считать дни только от out до in, которые ща на руках не учитывать).
* 
*/

namespace LibraryBase
{
class Book 
{
public int BookID {get; set;}
public int YearEditionBook {get; set;}
public string AuthorBook {get; set;}
public string BookName {get; set;}

public Book(int id, string author, string book, int date)
{
    BookID = id;            
    AuthorBook = author;
    BookName = book;
    YearEditionBook = date;
}       

public static void PrintBookLibrary(List<Book> list)
{
    foreach (Book bk in list)
        PrintBook(bk);
}

public static void PrintBook(Book bookT)
{
    Console.WriteLine(bookT.BookID + " " + bookT.AuthorBook+  " " + bookT.BookName + " " + bookT.YearEditionBook);
}

public static Book AddBook(List<string> list)
{
    int id = int.Parse(list[0]);
    string name = list[1];
    string bookName = list[2];
    int dateBook = int.Parse(list[3]);

    return new Book(id, name, bookName, dateBook);
}

public static List<Book> CreateValuesList(string fileName)
{
    List<string> booksList = new List<string>();
    Program.WriteFileToList(fileName, booksList);
    List<List<string>> books = new List<List<string>>();
    Program.CreateListString(books, booksList);
    List<Book> bookLibrary = new List<Book>();
    foreach (List<string> list in books)
        bookLibrary.Add(Book.AddBook(list));

    return bookLibrary;
}
}

class User
{
public int UserID { get; set; }
public string UserName { get; set; }
public DateTime UserDateBirth { get; set; }

public User(int id, string name, DateTime date)
{
    UserID = id;
    UserName = name;
    UserDateBirth = date;
}          

public static void PrintUserLibrary(List<User> list)
{
    foreach (User ur in list)
        PrintUser(ur);
}

public static void PrintUser(User userT)
{
    Console.WriteLine(userT.UserID + " " + userT.UserName + " " + userT.UserDateBirth.ToString("d"));
}

public static User AddUser(List<string> list)
{
    int id = int.Parse(list[0]);
    string name = list[1];
    DateTime date = DateTime.Parse(list[2]);
    
    return new User(id, name, date);
}










public static List<User> CreateValuesList(string fileName)
{
    List<string> usersList = new List<string>();
    Program.WriteFileToList(fileName, usersList);
    List<List<string>> users = new List<List<string>>();
    Program.CreateListString(users, usersList);
    List<User> usersLibrary = new List<User>();
    foreach (List<string> list in users)
        usersLibrary.Add(User.AddUser(list));

    return usersLibrary;
}

public static DateTime MinDateUser(List<User> list)
{
    DateTime temp = list[0].UserDateBirth;

    for (int i = 1; i < list.Count; i++)
    {
        if (list[i].UserDateBirth < temp)
            temp = list[i].UserDateBirth;
        else { }
    }
    return temp;
}

public static void PrintYoungUserInfo(List<User> list, List<Journal> listJr, List<Book> bkList)
{
    DateTime minDate = User.MinDateUser(list);
    foreach (User usr in list)
    {
        if (usr.UserDateBirth == minDate)
            User.PrintUser(usr);
    }

    int minUserID = 0;

    foreach (User usr in list)
    {
        if (usr.UserDateBirth == minDate)
            minUserID = usr.UserID;
    }

    Console.WriteLine();

    foreach (Journal jorn in listJr)
    {
        if (jorn.UserID == minUserID && jorn.isReaded == true)
            Book.PrintBook(bkList[jorn.BookID - 1]);
    }
}
}




class Journal
{
public bool isReaded { get; set; }
public DateTime BookInOutLibrary { get; set; }
public int UserID { get; set; }
public int BookID { get; set; }

public Journal(int x, int y, DateTime date, bool value)
{
    UserID = x;
    BookID = y;
    BookInOutLibrary = date;
    isReaded = value;
}

public static Journal AddJournal(List<string> list)
{
    int userID = int.Parse(list[0]);
    int bookID = int.Parse(list[1]);
    DateTime tempDate = DateTime.Parse(list[2]);
    bool value = (list[3] == "in");

    return new Journal(userID, bookID, tempDate, value);
}

public static void PrintJournalLibrary(List<Journal> list)
{
    foreach (Journal jr in list)
        PrintJournal(jr);
}

public static void PrintJournal(Journal journ)
{
    Console.WriteLine(journ.UserID + " " + journ.BookID + " " + journ.BookInOutLibrary + " " + journ.isReaded);
}

public static List<Journal> CreateValuesList(string fileName)
{
    List<string> journalList = new List<string>();
    Program.WriteFileToList(fileName, journalList);
    List<List<string>> journal = new List<List<string>>();
    Program.CreateListString(journal, journalList);
    List<Journal> journalLibrary = new List<Journal>();
    foreach (List<string> list in journal)
        journalLibrary.Add(Journal.AddJournal(list));

    return journalLibrary;
}








public static void PrintPopularBook(List<Book> books, List<Journal> journ)
{
    List<int> list = Journal.PopularBook(journ);

    for (int i = 0; i < list.Count; i++)
    {
        Book.PrintBook(books[list[i] - 1]);
    }
}

public static List<int> PopularBook(List<Journal> list)
{
    var result = from ls in list
                 where ls.isReaded == false
                 group ls by ls.BookID into b
                 let count = b.Count()
                 select new
                 {
                     Letter = b.Key,
                     Count = count
                 };

    var maxNum = result.Max(n => n.Count);

    List<int> listMax = new List<int>();

    foreach (var item in result)
    {
        if (item.Count == maxNum)
            listMax.Add(item.Letter);
        else
        { }
    }

    return listMax;
}
}


class Program
{
public static void WriteFileToList(string file, List<string> list)
{
    foreach (string str in File.ReadLines(file))
        list.Add(str);
}

public static void CreateListString(List<List<string>> outList, List<string> inList)
{
    foreach (string str in inList)
        outList.Add(str.Split(new[] { "\t" }, StringSplitOptions.RemoveEmptyEntries).ToList());
}   




static void Main(string[] args)
{
    // books.txt; user.txt; journal.txt
    List<Book> bookLibrary = Book.CreateValuesList("books.txt");
    Book.PrintBookLibrary(bookLibrary);

    Console.WriteLine();

    List<User> userLibrary = User.CreateValuesList("user.txt");
    User.PrintUserLibrary(userLibrary);

    Console.WriteLine();

    List<Journal> journalLibrary = Journal.CreateValuesList("journal.txt");
    Journal.PrintJournalLibrary(journalLibrary);

    Console.WriteLine();


    Console.WriteLine("Задание № 1: \"Вывести на экран информацию о книге, которую чаще всего читают\"\n");                       

    Journal.PrintPopularBook(bookLibrary, journalLibrary);

    Console.WriteLine("\n");
    

    Console.WriteLine("Задание № 2: \"Вывести на экран информацию о самом молодом читателе, а также список книг, которые он читал\"\n");
                
    User.PrintYoungUserInfo(userLibrary, journalLibrary, bookLibrary);                       

    Console.WriteLine("\n");

    Console.ReadKey();
}
}
}


















1 Орловский Гай Ричард Длинные Руки - барон 2005
2 Черненко Алексей Красивое название книги 2015
3 Кош Алекс Огненный Орден 2011
4 Риордан Рик Перси Джексон и проклятие титана 2016
5 Панов Вадим Хаосовершенство 2015

100 Иванов 21.09.1985
101 Петров 17.04.1989
102 Сидоров 08.12.1981

100 4 05.01.2017 0:00:00 False
101 3 09.01.2017 0:00:00 False
102 1 10.01.2017 0:00:00 False
100 4 13.01.2017 0:00:00 True
100 2 16.01.2017 0:00:00 False
102 1 19.01.2017 0:00:00 True
101 3 20.01.2017 0:00:00 True
101 4 23.01.2017 0:00:00 False
102 5 24.01.2017 0:00:00 False
101 4 26.01.2017 0:00:00 True
101 1 27.01.2017 0:00:00 False
100 2 31.01.2017 0:00:00 True
102 5 02.02.2017 0:00:00 True
102 3 07.02.2017 0:00:00 False
101 1 10.02.2017 0:00:00 True
102 3 14.02.2017 0:00:00 True
102 4 15.02.2017 0:00:00 False
100 3 17.02.2017 0:00:00 False

Задание № 1: "Вывести на экран информацию о книге, которую чаще всего читают"

4 Риордан Рик Перси Джексон и проклятие титана 2016
3 Кош Алекс Огненный Орден 2011


Задание № 2: "Вывести на экран информацию о самом молодом читателе, а также спис
ок книг, которые он читал"

102 Сидоров 08.12.1981

1 Орловский Гай Ричард Длинные Руки - барон 2005
5 Панов Вадим Хаосовершенство 2015
3 Кош Алекс Огненный Орден 2011













books.txt

1	Орловский Гай		Ричард Длинные Руки – барон		2005
2	Черненко Алексей	Красивое название книги			2015
3	Кош Алекс		Огненный Орден				2011
4	Риордан Рик		Перси Джексон и проклятие титана	2016
5	Панов Вадим		Хаосовершенство				2015

journal.txt

100	4	05.01.2017	out
101	3	09.01.2017	out
102	1	10.01.2017	out
100	4	13.01.2017	in
100	2	16.01.2017	out
102	1	19.01.2017	in
101	3	20.01.2017	in
101	4	23.01.2017	out
102	5	24.01.2017	out
101	4	26.01.2017	in
101	1	27.01.2017	out
100	2	31.01.2017	in
102	5	02.02.2017	in
102	3	07.02.2017	out
101	1	10.02.2017	in
102	3	14.02.2017	in
102	4	15.02.2017	out
100	3	17.02.2017	out

user.txt

100	Иванов	21.09.1985
101	Петров	17.04.1989
102	Сидоров	08.12.1981






















using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Task1
{

/*надо считать текст из файла и вывести на экран самое длинное и самое короткое слово (если попадется несколько - то вывести все, повторы игнорировать).
потом вывести в другой файл список всех слов, отсортированный по длине.*/



class Program
{
private static void PrintValue(List<string> list)
{
    foreach (string str in list)
        Console.Write(str + " ");

    Console.WriteLine();
}

private static void SortList(List<string> list)
{
    bool swapped;

    do
    {
        swapped = false;
        for (int i = 1; i < list.Count; i++)
        {
            if (list[i].Length < list[i - 1].Length)
            {
                Swap(list, i, i - 1);
                swapped = true;
            }
        }
    } while (swapped != false);
}

private static void Swap(List<string> list, int x, int y)
{
    if (x == y) return;

    string temp = list[x];
    list[x] = list[y];
    list[y] = temp;
}




static void Main(string[] args)
{
    string textFile = "basn.txt";

    string allText = File.ReadAllText(textFile);

    List<string> listWords = allText.Split(new[] {" ",".",",",";","-","\n", "\r"},  
                                                             StringSplitOptions.RemoveEmptyEntries)
                                                           .ToList();

    listWords.Sort();

    listWords.RemoveAt(0);

    SortList(listWords);

    List<string> wordsMin = new List<string>();

    List<string> wordsMax = new List<string>();


    for (int i = 0; i < listWords.Count; i++)
    {
        if (listWords[i].Length == listWords[0].Length)
        {
           wordsMin.Add(listWords[i]);
        }

        if (listWords[i].Length == listWords[listWords.Count-1].Length)
        {
            wordsMax.Add(listWords[i]);
        }
    }

    Console.Write("Самые короткие слова: ");

    PrintValue(wordsMin);                

    Console.Write("Самые короткие слова: ");

    PrintValue(wordsMax);
    
    //FileStream fileOut = new FileStream("fileOut.txt", FileMode.Create);

    StreamWriter fileOut2 = new StreamWriter("fileOut.txt");

    foreach (string str in listWords)
        fileOut2.WriteLine(str);

    fileOut2.Close();

    Console.ReadKey();

}
}
}

Самые короткие слова: а к с
Самые короткие слова: взгромоздясь Позавтракать позадумалась


fileOut.txt

а
к
с
во
Да
на
На
На
не
то
ту
уж
Бог
где
дух
ель
рту
сыр
сыр
сыр
беду
было
глаз
Лиса
Лису
сыра
Вдруг
видит
бежала
Вертит
Ворона
Вороне
Вороны
дереву
Лисица
Лисицу
пленил
послал
сводит
совсем
сырный
держала
кусочек
хвостом
Плутовка
подходит
цыпочках
собралась
остановил:
близёхонько
взгромоздясь
Позавтракать
позадумалась
